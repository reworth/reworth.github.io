<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reworth&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reworth.site/"/>
  <updated>2018-01-04T09:14:26.776Z</updated>
  <id>http://reworth.site/</id>
  
  <author>
    <name>Reworth Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jp-words-1</title>
    <link href="http://reworth.site/2018/01/04/Jp-words-1/"/>
    <id>http://reworth.site/2018/01/04/Jp-words-1/</id>
    <published>2018-01-04T09:12:51.000Z</published>
    <updated>2018-01-04T09:14:26.776Z</updated>
    
    <content type="html"><![CDATA[<p>あいそう「愛想」 讨厌，招待</p><p>間柄「あいだがら」关系</p><p>敢えて「あえて」特意，并不</p><p>あなたの将来のために、敢えて忠告「ちゅうこく」します</p><p>どうしても行きたいなら、私はあえて反対しない</p><p>浅ましい「あさましい」卑鄙</p><p>欺く「あざむく」</p><p>嘲笑う「あさわらう」</p><p>あせる「焦る、褪せる」着急</p><p>朝寝坊「あさねぼう」睡懒觉</p><p>後回し「あとまわし」推迟</p><p>彼が自分のことを後回しにしても、他の人を助けるような人だ。</p><p>あやふや  含糊</p><p>彼のあやふやな態度に、彼女は激怒「げきど」した。</p><p>過ち「あやまち」 过错</p><p>誰でも若い時は、過ちの一つや二つおかす。</p><p>あらっぽい「荒っぽい、粗っぽい」  粗野</p><p>彼はあらっぽい性格に見えますが、実は優しい人なんです。</p><p>あらかじめ「予め」 预先</p><p>あらかじめ必要なものをメモしていくと、無駄な買い物をしない。</p><p>ありのまま   老实，坦白</p><p>ありのままの私を認めてくれる人と結婚したいと思っている</p><p>案の定「あんのじょう」果然，果如所料</p><p>連休中の新幹線は、案の定、込んでいた。</p><p>いかにも  果然</p><p>いかにも、おっしゃる通りです。彼はいかにも優等生のダイプだ。</p><p>幾多「いくた」许多</p><p>父は、幾多の困難を乗り越えて、会社大きくしてきたそうだ</p><p>一括「いっかつ」 汇总。一包在内</p><p>時間がないので、三つの議案を一括して審議「しんぎ」する</p><p>意図「いと」  意图</p><p>著者のいとがよくわからない本だ</p><p>今更「いまさら」  事到如今</p><p>いまさら謝られでも、もう遲い。</p><p>いやいや「嫌々」  勉勉强强</p><p>内訳「うちわけ」  详细内容</p><p>進歩「しんぽ」     进步</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;あいそう「愛想」 讨厌，招待&lt;/p&gt;
&lt;p&gt;間柄「あいだがら」关系&lt;/p&gt;
&lt;p&gt;敢えて「あえて」特意，并不&lt;/p&gt;
&lt;p&gt;あなたの将来のために、敢えて忠告「ちゅうこく」します&lt;/p&gt;
&lt;p&gt;どうしても行きたいなら、私はあえて反対しない&lt;/p&gt;
&lt;p&gt;浅ましい「あさましい」
      
    
    </summary>
    
      <category term="japaness" scheme="http://reworth.site/categories/japaness/"/>
    
    
      <category term="japaness" scheme="http://reworth.site/tags/japaness/"/>
    
  </entry>
  
  <entry>
    <title>vagrant</title>
    <link href="http://reworth.site/2018/01/04/vagrant/"/>
    <id>http://reworth.site/2018/01/04/vagrant/</id>
    <published>2018-01-04T08:27:57.000Z</published>
    <updated>2018-01-04T08:30:09.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vagrant常用命令"><a href="#Vagrant常用命令" class="headerlink" title="Vagrant常用命令"></a>Vagrant常用命令</h2><p>Vagrant Cmd：</p><ul><li><code>vagrant box add</code> 添加box的操作</li><li><code>vagrant init</code> 初始化box的操作</li><li><code>vagrant up</code> 启动虚拟机的操作</li><li><code>vagrant ssh</code> 登录虚拟机的操作</li></ul><p>Vagrant还包括如下一些操作：</p><ul><li><p><code>vagrant box list</code><br>  显示当前已经添加的box列表</p><pre><code>$ vagrant box listbase (virtualbox)</code></pre></li><li><p><code>vagrant box remove</code><br>  删除相应的box</p><pre><code>$ vagrant box remove base virtualboxRemoving box &apos;base&apos; with provider &apos;virtualbox&apos;...</code></pre></li><li><p><code>vagrant destroy</code><br>  停止当前正在运行的虚拟机并销毁所有创建的资源</p><pre><code>$ vagrant destroyAre you sure you want to destroy the &apos;default&apos; VM? [y/N] y[default] Destroying VM and associated drives...</code></pre></li><li><p><code>vagrant halt</code>  </p><p>  关机</p><pre><code>$ vagrant halt[default] Attempting graceful shutdown of VM...</code></pre></li><li><p><code>vagrant package</code></p><p>  打包命令，可以把当前的运行的虚拟机环境进行打包</p><pre><code>$ vagrant package[default] Attempting graceful shutdown of VM...[default] Clearing any previously set forwarded ports...[default] Creating temporary directory for export...[default] Exporting VM...[default] Compressing package to: /Users/astaxie/vagrant/package.box</code></pre></li><li><p><code>vagrant plugin</code></p><p>  用于安装卸载插件</p></li><li><p><code>vagrant provision</code></p><p>  通常情况下Box只做最基本的设置，而不是设置好所有的环境，因此Vagrant通常使用Chef或者Puppet来做进一步的环境搭建。那么Chef或者Puppet称为provisioning，而该命令就是指定开启相应的provisioning。按照Vagrant作者的说法，所谓的provisioning就是”The problem of installing software on a booted system”的意思。除了Chef和Puppet这些主流的配置管理工具之外，我们还可以使用Shell来编写安装脚本。</p><p>  例如： <code>vagrant provision --provision-with chef</code></p></li><li><p><code>vagrant reload</code>  </p><p>  重新启动虚拟机，主要用于重新载入配置文件</p><pre><code>$ vagrant reload[default] Attempting graceful shutdown of VM...[default] Setting the name of the VM...[default] Clearing any previously set forwarded ports...[default] Creating shared folders metadata...[default] Clearing any previously set network interfaces...[default] Preparing network interfaces based on configuration...[default] Forwarding ports...[default] -- 22 =&gt; 2222 (adapter 1)[default] Booting VM...[default] Waiting for VM to boot. This can take a few minutes.[default] VM booted and ready for use![default] Setting hostname...[default] Mounting shared folders...[default] -- /vagrant</code></pre></li><li><p><code>vagrant resume</code></p><p>  恢复前面被挂起的状态</p><pre><code>$vagrant resume[default] Resuming suspended VM...[default] Booting VM...[default] Waiting for VM to boot. This can take a few minutes.[default] VM booted and ready for use!</code></pre></li><li><p><code>vagrant ssh-config</code></p><p>  输出用于ssh连接的一些信息</p><pre><code>$vagrant ssh-configHost default  HostName 127.0.0.1  User vagrant  Port 2222  UserKnownHostsFile /dev/null  StrictHostKeyChecking no  PasswordAuthentication no  IdentityFile &quot;/Users/astaxie/.vagrant.d/insecure_private_key&quot;  IdentitiesOnly yes  LogLevel FATAL</code></pre></li><li><p><code>vagrant status</code></p><p>  获取当前虚拟机的状态</p><pre><code>$vagrant statusCurrent machine states:default                   running (virtualbox)The VM is running. To stop this VM, you can run `vagrant halt` toshut it down forcefully, or you can run `vagrant suspend` to simplysuspend the virtual machine. In either case, to restart it again,simply run `vagrant up`.</code></pre></li><li><p><code>vagrant suspend</code></p><p>  挂起当前的虚拟机</p><pre><code>$ vagrant suspend[default] Saving VM state and suspending execution...</code></pre></li></ul><h2 id="模拟打造多机器的分布式系统"><a href="#模拟打造多机器的分布式系统" class="headerlink" title="模拟打造多机器的分布式系统"></a>模拟打造多机器的分布式系统</h2><p>前面这些单主机单虚拟机主要是用来自己做开发机，从这部分开始的内容主要将向大家介绍如何在单机上通过虚拟机来打造分布式造集群系统。这种多机器模式特别适合以下几种人：</p><ol><li>快速建立产品网络的多机器环境，例如web服务器、db服务器</li><li>建立一个分布式系统，学习他们是如何交互的</li><li>测试API和其他组件的通信</li><li>容灾模拟，网络断网、机器死机、连接超时等情况</li></ol><p>Vagrant支持单机模拟多台机器，而且支持一个配置文件Vagrntfile就可以跑分布式系统。</p><p>现在我们来建立多台VM跑起來，並且让他们之间能够相通信，假设一台是应用服务器、一台是DB服务器，那么这个结构在Vagrant中非常简单，其实和单台的配置差不多，你只需要通过<code>config.vm.define</code>来定义不同的角色就可以了，现在我们打开配置文件进行如下设置：</p><pre><code>Vagrant.configure(&quot;2&quot;) do |config|  config.vm.define :web do |web|    web.vm.provider &quot;virtualbox&quot; do |v|          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;web&quot;, &quot;--memory&quot;, &quot;512&quot;]    end    web.vm.box = &quot;base&quot;    web.vm.hostname = &quot;web&quot;    web.vm.network :private_network, ip: &quot;11.11.1.1&quot;  end  config.vm.define :db do |db|    db.vm.provider &quot;virtualbox&quot; do |v|          v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;db&quot;, &quot;--memory&quot;, &quot;512&quot;]    end    db.vm.box = &quot;base&quot;    db.vm.hostname = &quot;db&quot;    db.vm.network :private_network, ip: &quot;11.11.1.2&quot;  endend</code></pre><p>这里的设置和前面我们单机设置配置类似，只是我们使用了<code>:web</code>以及<code>:db</code>分別做了两个VM的设置，并且给每个VM设置了不同的<code>hostname</code>和IP，设置好之后再使用<code>vagrant up</code>将虚拟机跑起来：</p><pre><code>$ vagrant upBringing machine &apos;web&apos; up with &apos;virtualbox&apos; provider...Bringing machine &apos;db&apos; up with &apos;virtualbox&apos; provider...[web] Setting the name of the VM...[web] Clearing any previously set forwarded ports...[web] Creating shared folders metadata...[web] Clearing any previously set network interfaces...[web] Preparing network interfaces based on configuration...[web] Forwarding ports...[web] -- 22 =&gt; 2222 (adapter 1)[web] Running any VM customizations...[web] Booting VM...[web] Waiting for VM to boot. This can take a few minutes.[web] VM booted and ready for use![web] Setting hostname...[web] Configuring and enabling network interfaces...[web] Mounting shared folders...[web] -- /vagrant[db] Setting the name of the VM...[db] Clearing any previously set forwarded ports...[db] Fixed port collision for 22 =&gt; 2222. Now on port 2200.[db] Creating shared folders metadata...[db] Clearing any previously set network interfaces...[db] Preparing network interfaces based on configuration...[db] Forwarding ports...[db] -- 22 =&gt; 2200 (adapter 1)[db] Running any VM customizations...[db] Booting VM...[db] Waiting for VM to boot. This can take a few minutes.[db] VM booted and ready for use![db] Setting hostname...[db] Configuring and enabling network interfaces...[db] Mounting shared folders...[db] -- /vagrant</code></pre><p>看到上面的信息输出后，我们就可以通过<code>vagrant ssh</code>登录虚拟机了，但是这次和上次使用的不一样了，这次我们需要指定相应的角色，用来告诉ssh你期望连接的是哪一台：</p><pre><code>$ vagrant ssh webvagrant@web:~$$ vagrant ssh dbvagrant@db:~$</code></pre><p>是不是很酷！现在接下来我们再来验证一下虚拟机之间的通信，让我们先使用ssh登录web虚拟机，然后在web虚拟机上使用ssh登录db虚拟机(默认密码是<code>vagrant</code>)：</p><pre><code>$ vagrant ssh webLinux web 2.6.32-38-server #83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/LinuxUbuntu 10.04.4 LTSWelcome to the Ubuntu Server! * Documentation:  http://www.ubuntu.com/server/docNew release &apos;precise&apos; available.Run &apos;do-release-upgrade&apos; to upgrade to it.Welcome to your Vagrant-built virtual machine.Last login: Thu Aug  8 18:55:44 2013 from 10.0.2.2vagrant@web:~$ ssh 11.11.1.2The authenticity of host &apos;11.11.1.2 (11.11.1.2)&apos; can&apos;t be established.RSA key fingerprint is e7:8f:07:57:69:08:6e:fa:82:bc:1c:f6:53:3f:12:9e.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;11.11.1.2&apos; (RSA) to the list of known hosts.vagrant@11.11.1.2&apos;s password:Linux db 2.6.32-38-server #83-Ubuntu SMP Wed Jan 4 11:26:59 UTC 2012 x86_64 GNU/LinuxUbuntu 10.04.4 LTSWelcome to the Ubuntu Server! * Documentation:  http://www.ubuntu.com/server/docNew release &apos;precise&apos; available.Run &apos;do-release-upgrade&apos; to upgrade to it.Welcome to your Vagrant-built virtual machine.Last login: Thu Aug  8 18:58:50 2013 from 10.0.2.2vagrant@db:~$</code></pre><p>通过上面的信息我们可以看到虚拟机之间通信是畅通的，所以现在开始你伟大的架构设计吧，你想设计怎么样的架构都可以，唯一限制你的就是你主机的硬件配置了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vagrant常用命令&quot;&gt;&lt;a href=&quot;#Vagrant常用命令&quot; class=&quot;headerlink&quot; title=&quot;Vagrant常用命令&quot;&gt;&lt;/a&gt;Vagrant常用命令&lt;/h2&gt;&lt;p&gt;Vagrant Cmd：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;va
      
    
    </summary>
    
      <category term="vagrant" scheme="http://reworth.site/categories/vagrant/"/>
    
    
      <category term="vagrant" scheme="http://reworth.site/tags/vagrant/"/>
    
  </entry>
  
  <entry>
    <title>hexo cmd</title>
    <link href="http://reworth.site/2018/01/03/hexo-cmd/"/>
    <id>http://reworth.site/2018/01/03/hexo-cmd/</id>
    <published>2018-01-03T11:56:46.000Z</published>
    <updated>2018-01-03T12:00:30.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Cmd"><a href="#Hexo-Cmd" class="headerlink" title="Hexo Cmd"></a>Hexo Cmd</h1><blockquote><p>hexo help  # 查看帮助<br>hexo version  #查看Hexo的版本<br>hexo algolia  # 更新search庫<br>hexo new “postName” #新建文章<br>hexo new post “title”  # 生成新文章：\source_posts\title.md，可省略post<br>hexo new page “pageName” #新建页面<br>hexo clean #清除部署緩存<br>hexo n == hexo new #新建文章<br>hexo g == hexo generate #生成静态页面至public目录<br>hexo s == hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo d == hexo deploy #将.deploy目录部署到GitHub<br>hexo d -g #生成加部署<br>hexo s -g #生成加预览</p></blockquote><h1 id="Clean-amp-Update"><a href="#Clean-amp-Update" class="headerlink" title="Clean&amp;Update"></a>Clean&amp;Update</h1><pre><code>hexo clhexo d -g</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-Cmd&quot;&gt;&lt;a href=&quot;#Hexo-Cmd&quot; class=&quot;headerlink&quot; title=&quot;Hexo Cmd&quot;&gt;&lt;/a&gt;Hexo Cmd&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;hexo help  # 查看帮助&lt;br&gt;hexo version
      
    
    </summary>
    
      <category term="hexo" scheme="http://reworth.site/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://reworth.site/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>flask definitions</title>
    <link href="http://reworth.site/2018/01/03/flask-definitions/"/>
    <id>http://reworth.site/2018/01/03/flask-definitions/</id>
    <published>2018-01-03T11:16:42.000Z</published>
    <updated>2018-01-03T11:45:22.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flask’s-some-definitions"><a href="#Flask’s-some-definitions" class="headerlink" title="Flask’s some definitions"></a>Flask’s some definitions</h1><ul><li>WSGI: Web服务器网关接口，是一种Web服务使用的协议</li><li>路由: 处理URL和函数之间关系的程序称为”路由”</li><li>视图函数: 类似于index()这样的，被app.route装饰器注册为路由的函数，或者通过app.add_url_rule()添加路由映射关系的函数，被称为视图函数。  </li><li>app.route(): 路由装饰器，可以带参数，参数可以指定数据类型：int/float/path。path类似于字符串，但不将反斜线/当做分隔符。 </li></ul><h1 id="Flask上下文全局变量"><a href="#Flask上下文全局变量" class="headerlink" title="Flask上下文全局变量"></a>Flask上下文全局变量</h1><ul><li>current_app: 程序上下文，当前激活程序的程序实例，所有线程公用一个该实例。 </li><li>g: 程序上下文，处理请求时用作临时存储的对象，每次请求都会重设这个变量</li><li>request: 请求上下文，请求对象，封装了客户端发出的 HTTP 请求中的内容，不同线程之间互不干扰</li><li>session: 请求上下问，用户会话，用于存储请求之间需要“记住”的值的词典。 </li></ul><h1 id="Flask支持的4种钩子函数"><a href="#Flask支持的4种钩子函数" class="headerlink" title="Flask支持的4种钩子函数"></a>Flask支持的4种钩子函数</h1><ul><li>before_first_request: 注册一个函数，在处理第一个请求之前运行。 </li><li>before_request: 注册一个函数，在每次请求之前运行。</li><li>after_request: 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。</li><li>teardown_request:注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。</li></ul><h1 id="Jinja2模板使用"><a href="#Jinja2模板使用" class="headerlink" title="Jinja2模板使用"></a>Jinja2模板使用</h1><p>渲染模板: render_template(“user.html”, name=name)<br>控制结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user %&#125; </span><br><span class="line">      Hello, &#123;&#123; user &#125;&#125;! </span><br><span class="line">    &#123;% else %&#125; </span><br><span class="line">      Hello, Stranger! </span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt; </span><br><span class="line">    &#123;% for comment in comments %&#125; </span><br><span class="line">      &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;  </span><br><span class="line">       &#123;% endfor %&#125; </span><br><span class="line">    &lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>宏-类似于函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &#123;% macro render_comment(comment) %&#125; </span><br><span class="line">   &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt; </span><br><span class="line"> &#123;% endmacro %&#125; </span><br><span class="line"> </span><br><span class="line"> &lt;ul&gt; </span><br><span class="line"> &#123;% for comment in comments %&#125; </span><br><span class="line">   &#123;&#123; render_comment(comment) &#125;&#125; </span><br><span class="line"> &#123;% endfor %&#125; </span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><h1 id="Jinja2变量过滤器"><a href="#Jinja2变量过滤器" class="headerlink" title="Jinja2变量过滤器"></a>Jinja2变量过滤器</h1><blockquote><p># safe: 渲染值时不转义<br># capitalize: 把值的首字母转换成大写，其他字母转换成小写<br># lower: 把值转换成小写形式<br># upper: 把值转换成大写形式<br># title: 把值中每个单词的首字母都转换成大写<br># trim: 把值的首尾空格去掉<br># striptags: 渲染之前把值中所有的 HTML 标签都删掉 </p></blockquote><h1 id="WTForms支持的字段"><a href="#WTForms支持的字段" class="headerlink" title="WTForms支持的字段"></a>WTForms支持的字段</h1><p><strong>注意添加app.config[‘SECRET_KEY’] = ‘hard to guess string’</strong></p><ul><li>StringField 文本字段 </li><li>TextAreaField 多行文本字段 </li><li>PasswordField 密码文本字段 </li><li>HiddenField 隐藏文本字段 </li><li>DateField 值为datatime.data格式的文本字段 </li><li>DateTimeField 值为datatime.datatime格式的文本字段 </li><li>DecimalField 值为decimal.Decimal格式的文本字段 </li><li>IntegerField 值为整数的文本字段 </li><li>FloatField 值为浮点数的文本字段 </li><li>BooleanField 值为True或False的复选框 </li><li>RadioField 一组单选框 </li><li>SelectField 值唯一的下拉列表 </li><li>SelectMultipleField 可选多个值得下拉列表 </li><li>FileField 文件上传字段 </li><li>SubmitField 表单提交按钮 </li><li>FormField 把表单作为字段嵌入另一个表单 </li><li>FieldList 一组指定类型的字段 </li></ul><h1 id="常见返回码"><a href="#常见返回码" class="headerlink" title="常见返回码"></a>常见返回码</h1><p>200 OK - [GET]：服务器成功返回用户请求的数据<br>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功<br>202 Accepted - [<em>]：表示一个请求已经进入后台排队（异步任务）<br>204 NO CONTENT - [DELETE]：用户删除数据成功<br>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作<br>401 Unauthorized - [</em>]：表示用户没有权限（令牌、用户名、密码错误）<br>403 Forbidden - [<em>] 表示用户得到授权（与401错误相对），但是访问是被禁止的<br>404 NOT FOUND - [</em>]：用户发出的请求针对的是不存在的记录，服务器没有进行操作<br>406 Not Acceptable - [GET]：用户请求的格式不可得<br>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的<br>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误<br>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flask’s-some-definitions&quot;&gt;&lt;a href=&quot;#Flask’s-some-definitions&quot; class=&quot;headerlink&quot; title=&quot;Flask’s some definitions&quot;&gt;&lt;/a&gt;Flask’s some d
      
    
    </summary>
    
      <category term="flask" scheme="http://reworth.site/categories/flask/"/>
    
    
      <category term="flask" scheme="http://reworth.site/tags/flask/"/>
    
      <category term="python" scheme="http://reworth.site/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>sed-grep</title>
    <link href="http://reworth.site/2018/01/01/sed-grep/"/>
    <id>http://reworth.site/2018/01/01/sed-grep/</id>
    <published>2018-01-01T09:20:47.000Z</published>
    <updated>2018-01-01T09:34:25.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed对文本的处理非常的强大，并且sed非常小，操作跟awk类似。sed是按顺序逐行进行读取文件。然后，它执行的是该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以将其存放到文件之中。</p><h2 id="sed-nefri-动作"><a href="#sed-nefri-动作" class="headerlink" title="sed  [-nefri] [动作]"></a>sed  [-nefri] [动作]</h2><ul><li>-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li><li>-e ：直接在命令列模式上进行 sed 的动作编辑；</li><li>-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</li><li>-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</li><li>-i ：直接修改读取的文件内容，而不是输出到终端。</li><li>–follow-symlinks    直接修改文件时跟随软链接</li></ul><p><strong>动作说明</strong> ： [n1[,n2]]fuction<br>n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』<br> <strong>funtion</strong>：</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><strong>命令格式</strong>： grep [option] pattern file</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>-i：忽略大小写</li><li>-c：打印匹配的行数</li><li>-v：查找不包含匹配项的行</li><li>-n：打印包含匹配项的行和行标</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>^  #锚定行的开始 如：’^grep’匹配所有以grep开头的行。<br>$  #锚定行的结束 如：’grep$’匹配所有以grep结尾的行。<br>.  #匹配一个非换行符的字符 如：’gr.p’匹配gr后接一个任意字符，然后是p。<br>*  #匹配零个或多个先前字符 如：’<em>grep’匹配所有一个或多个空格后紧跟grep的行。<br>.</em>   #一起用代表任意字符。<br>[]   #匹配一个指定范围内的字符，如’[Gg]rep’匹配Grep和grep。<br>[^]  #匹配一个不在指定范围内的字符，如：’[^A-FH-Z]rep’匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。<br>(..)  #标记匹配字符，如’(love)‘，love被标记为1。<br>\&lt;      #锚定单词的开始，如:’\<grep'匹配包含以grep开头的单词的行。 \="">      #锚定单词的结束，如'grep\>‘匹配包含以grep结尾的单词的行。<br>x{m}  #重复字符x，m次，如：’0{5}‘匹配包含5个o的行。<br>x{m,}  #重复字符x,至少m次，如：’o{5,}‘匹配至少有5个o的行。<br>x{m,n}  #重复字符x，至少m次，不多于n次，如：’o{5,10}‘匹配5–10个o的行。<br>\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：’G\w*p’匹配以G后跟零个或多个文字或数字字符，然后是p。<br>\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </grep'匹配包含以grep开头的单词的行。></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sed&quot;&gt;&lt;a href=&quot;#sed&quot; class=&quot;headerlink&quot; title=&quot;sed&quot;&gt;&lt;/a&gt;sed&lt;/h2&gt;&lt;p&gt;sed对文本的处理非常的强大，并且sed非常小，操作跟awk类似。sed是按顺序逐行进行读取文件。然后，它执行的是该行指定的所有操作
      
    
    </summary>
    
      <category term="linux" scheme="http://reworth.site/categories/linux/"/>
    
    
      <category term="sed" scheme="http://reworth.site/tags/sed/"/>
    
      <category term="grep" scheme="http://reworth.site/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>awk</title>
    <link href="http://reworth.site/2017/12/29/awk/"/>
    <id>http://reworth.site/2017/12/29/awk/</id>
    <published>2017-12-29T10:00:59.000Z</published>
    <updated>2017-12-29T10:43:12.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p><strong>awk</strong>是一种处理文本的语言，是一个强大的文本分析工具，awk是以列为划分记数的，$0表示所有列，$1表示第一列，$2表示第二列。</p><h2 id="awk常用参数"><a href="#awk常用参数" class="headerlink" title="awk常用参数"></a>awk常用参数</h2><ul><li>-F指定输入文件分隔符，如-F：</li><li>-v 赋值一个用户定义变量，如-va=1</li><li>-f 从脚本文件中读取awk命令</li></ul><h2 id="多个分隔符"><a href="#多个分隔符" class="headerlink" title="多个分隔符"></a>多个分隔符</h2><p><code>awk -F &#39;[-|]&#39; &#39;{print $3}&#39; data</code><br>上面这个例子是以-和|为分隔符进行分割。</p><h2 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h2><p>设置awk自定义变量，使用参数-v<br><code>cat data.txt | awk -v a=9 &#39;{print $1,$1+a}&#39;</code><br>如上，设置了变量a的值，在输出的时候添加一个$1+a的值。<br>如果在脚本中使用的时候，前面已经定义了一个$2的变量，并且你就是像要使用这个变量的话，就要使用以下的形式：<br><code>awk &#39;{print $$2}&#39;</code></p><h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><p><code>cat data.txt | awk &#39;$1==&quot;reworth&quot; {print}</code><br>输出第一列为reworth的所有行。<br><code>cat data.txt | awk &#39;$1!=&quot;reworth&quot; {print}&#39;</code><br>输出第一列不是reworth的所有行。</p><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p><code>cat data.txt | awk &#39;$2 ~ /reworth.*/ {print}&#39;</code><br>匹配第二列中以reworth开头的所有行。对某列进行匹配时需要在列之后加个～表示进行匹配。<br><code>cat data.txt | awk &#39;/reworth.*/ {print}&#39;</code><br>匹配以reworth开头的所有行。<br><strong>匹配取反</strong> !~<br><code>cat data.txt | awk &#39;$2 !~ /reworth/ {print}&#39;</code><br>匹配第二列不是reworth的所有行。</p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><ul><li>FILENAME : 当前输入文件名称</li><li>NF : 当前输入行的字段编号</li><li>OFS : 输出字段分隔符</li><li>NR : 当前输入行编号(是指输入行 1，2，3……等)</li><li>FS : 输入字段分隔符</li><li>ORS : 输出记录分隔符</li><li>RS : 输入记录分隔符</li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p><strong>substr字符串截取</strong><br><code>cat data.txt | awk &#39;{print substr($1,1,4)}&#39;</code><br>截取第一列中的第一个到第四个字符。<br><strong>split 切片</strong><br><code>cat data.txt |awk &#39;{split($1,a,&quot;,&quot;);print a[1],a[2],a[3]}&#39;</code><br>以逗号分隔第一列，并输出分隔后的数据。<br><strong>gsub 替换</strong><br><code>cat data.txt | awk &#39;&#39;{gsub(&quot;abc&quot;,&quot;asd&quot;,$2);print}</code><br>将第二列中的abc替换成asd</p><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><blockquote><p>grep ‘tower_activity_op’ /data/s*/log/test.log  | awk -F’[=,]’ ‘{a[$2] -= $12; b[$2] -= $14; item_count[$2]++;} END{for(i in a) {serverid=i;  cmd=”/usr/bin/mysql -u root -h \”192.168.0.1\” -p1234 -D stat -e \”replace into test(date,uid,cash,coins,number,code,serverid) values(\047’$Date’\047,”i”,”a[i]”,”b[i]”,”item_count[i]”,\047测试\047,”serverid”)\””; system(cmd);}}’ </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;awk&quot;&gt;&lt;a href=&quot;#awk&quot; class=&quot;headerlink&quot; title=&quot;awk&quot;&gt;&lt;/a&gt;awk&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;是一种处理文本的语言，是一个强大的文本分析工具，awk是以列为划分记数的，$0表示所有列，$
      
    
    </summary>
    
      <category term="linux" scheme="http://reworth.site/categories/linux/"/>
    
    
      <category term="awk" scheme="http://reworth.site/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>volume-container</title>
    <link href="http://reworth.site/2017/12/28/volume-container/"/>
    <id>http://reworth.site/2017/12/28/volume-container/</id>
    <published>2017-12-28T11:00:24.000Z</published>
    <updated>2017-12-29T07:03:58.446Z</updated>
    
    <content type="html"><![CDATA[<p>volume container是专门为其他容器提供volume的容器。它提供的卷可以是bind mount,<br>也可以是docker managed volume.下面我创建一个volume container:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker create --name vc_data \</span><br><span class="line">-v ~/htdocs:/usr/local/apache2/htdocs \</span><br><span class="line">-v ~/other/useful/tools \</span><br><span class="line">busybox</span><br></pre></td></tr></table></figure></p><p>我们将容器命名为vc_data.注意这里执行的是docker create命令，这是因为volume container<br>的作用是只提供数据，它本身不需要处于运行状态。容器中mount了两个volume:</p><ul><li>bind mount,存放web server的静态文件。</li><li>docker managed volume,存放一些实用的工具<br>通过docker inspect可以查看这两个volume</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volume container是专门为其他容器提供volume的容器。它提供的卷可以是bind mount,&lt;br&gt;也可以是docker managed volume.下面我创建一个volume container:&lt;br&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="docker" scheme="http://reworth.site/categories/docker/"/>
    
    
      <category term="volume" scheme="http://reworth.site/tags/volume/"/>
    
  </entry>
  
</feed>
