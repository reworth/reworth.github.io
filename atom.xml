<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reworth&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reworth.site/"/>
  <updated>2018-01-03T12:00:30.402Z</updated>
  <id>http://reworth.site/</id>
  
  <author>
    <name>Reworth Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo cmd</title>
    <link href="http://reworth.site/2018/01/03/hexo-cmd/"/>
    <id>http://reworth.site/2018/01/03/hexo-cmd/</id>
    <published>2018-01-03T11:56:46.000Z</published>
    <updated>2018-01-03T12:00:30.402Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Cmd"><a href="#Hexo-Cmd" class="headerlink" title="Hexo Cmd"></a>Hexo Cmd</h1><blockquote><p>hexo help  # 查看帮助<br>hexo version  #查看Hexo的版本<br>hexo algolia  # 更新search庫<br>hexo new “postName” #新建文章<br>hexo new post “title”  # 生成新文章：\source_posts\title.md，可省略post<br>hexo new page “pageName” #新建页面<br>hexo clean #清除部署緩存<br>hexo n == hexo new #新建文章<br>hexo g == hexo generate #生成静态页面至public目录<br>hexo s == hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo d == hexo deploy #将.deploy目录部署到GitHub<br>hexo d -g #生成加部署<br>hexo s -g #生成加预览</p></blockquote><h1 id="Clean-amp-Update"><a href="#Clean-amp-Update" class="headerlink" title="Clean&amp;Update"></a>Clean&amp;Update</h1><pre><code>hexo clhexo d -g</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-Cmd&quot;&gt;&lt;a href=&quot;#Hexo-Cmd&quot; class=&quot;headerlink&quot; title=&quot;Hexo Cmd&quot;&gt;&lt;/a&gt;Hexo Cmd&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;hexo help  # 查看帮助&lt;br&gt;hexo version
      
    
    </summary>
    
      <category term="hexo" scheme="http://reworth.site/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://reworth.site/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>flask definitions</title>
    <link href="http://reworth.site/2018/01/03/flask-definitions/"/>
    <id>http://reworth.site/2018/01/03/flask-definitions/</id>
    <published>2018-01-03T11:16:42.000Z</published>
    <updated>2018-01-03T11:45:22.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flask’s-some-definitions"><a href="#Flask’s-some-definitions" class="headerlink" title="Flask’s some definitions"></a>Flask’s some definitions</h1><ul><li>WSGI: Web服务器网关接口，是一种Web服务使用的协议</li><li>路由: 处理URL和函数之间关系的程序称为”路由”</li><li>视图函数: 类似于index()这样的，被app.route装饰器注册为路由的函数，或者通过app.add_url_rule()添加路由映射关系的函数，被称为视图函数。  </li><li>app.route(): 路由装饰器，可以带参数，参数可以指定数据类型：int/float/path。path类似于字符串，但不将反斜线/当做分隔符。 </li></ul><h1 id="Flask上下文全局变量"><a href="#Flask上下文全局变量" class="headerlink" title="Flask上下文全局变量"></a>Flask上下文全局变量</h1><ul><li>current_app: 程序上下文，当前激活程序的程序实例，所有线程公用一个该实例。 </li><li>g: 程序上下文，处理请求时用作临时存储的对象，每次请求都会重设这个变量</li><li>request: 请求上下文，请求对象，封装了客户端发出的 HTTP 请求中的内容，不同线程之间互不干扰</li><li>session: 请求上下问，用户会话，用于存储请求之间需要“记住”的值的词典。 </li></ul><h1 id="Flask支持的4种钩子函数"><a href="#Flask支持的4种钩子函数" class="headerlink" title="Flask支持的4种钩子函数"></a>Flask支持的4种钩子函数</h1><ul><li>before_first_request: 注册一个函数，在处理第一个请求之前运行。 </li><li>before_request: 注册一个函数，在每次请求之前运行。</li><li>after_request: 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。</li><li>teardown_request:注册一个函数，即使有未处理的异常抛出，也在每次请求之后运行。</li></ul><h1 id="Jinja2模板使用"><a href="#Jinja2模板使用" class="headerlink" title="Jinja2模板使用"></a>Jinja2模板使用</h1><p>渲染模板: render_template(“user.html”, name=name)<br>控制结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if user %&#125; </span><br><span class="line">      Hello, &#123;&#123; user &#125;&#125;! </span><br><span class="line">    &#123;% else %&#125; </span><br><span class="line">      Hello, Stranger! </span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt; </span><br><span class="line">    &#123;% for comment in comments %&#125; </span><br><span class="line">      &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt;  </span><br><span class="line">       &#123;% endfor %&#125; </span><br><span class="line">    &lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>宏-类似于函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &#123;% macro render_comment(comment) %&#125; </span><br><span class="line">   &lt;li&gt;&#123;&#123; comment &#125;&#125;&lt;/li&gt; </span><br><span class="line"> &#123;% endmacro %&#125; </span><br><span class="line"> </span><br><span class="line"> &lt;ul&gt; </span><br><span class="line"> &#123;% for comment in comments %&#125; </span><br><span class="line">   &#123;&#123; render_comment(comment) &#125;&#125; </span><br><span class="line"> &#123;% endfor %&#125; </span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><h1 id="Jinja2变量过滤器"><a href="#Jinja2变量过滤器" class="headerlink" title="Jinja2变量过滤器"></a>Jinja2变量过滤器</h1><blockquote><p># safe: 渲染值时不转义<br># capitalize: 把值的首字母转换成大写，其他字母转换成小写<br># lower: 把值转换成小写形式<br># upper: 把值转换成大写形式<br># title: 把值中每个单词的首字母都转换成大写<br># trim: 把值的首尾空格去掉<br># striptags: 渲染之前把值中所有的 HTML 标签都删掉 </p></blockquote><h1 id="WTForms支持的字段"><a href="#WTForms支持的字段" class="headerlink" title="WTForms支持的字段"></a>WTForms支持的字段</h1><p><strong>注意添加app.config[‘SECRET_KEY’] = ‘hard to guess string’</strong></p><ul><li>StringField 文本字段 </li><li>TextAreaField 多行文本字段 </li><li>PasswordField 密码文本字段 </li><li>HiddenField 隐藏文本字段 </li><li>DateField 值为datatime.data格式的文本字段 </li><li>DateTimeField 值为datatime.datatime格式的文本字段 </li><li>DecimalField 值为decimal.Decimal格式的文本字段 </li><li>IntegerField 值为整数的文本字段 </li><li>FloatField 值为浮点数的文本字段 </li><li>BooleanField 值为True或False的复选框 </li><li>RadioField 一组单选框 </li><li>SelectField 值唯一的下拉列表 </li><li>SelectMultipleField 可选多个值得下拉列表 </li><li>FileField 文件上传字段 </li><li>SubmitField 表单提交按钮 </li><li>FormField 把表单作为字段嵌入另一个表单 </li><li>FieldList 一组指定类型的字段 </li></ul><h1 id="常见返回码"><a href="#常见返回码" class="headerlink" title="常见返回码"></a>常见返回码</h1><p>200 OK - [GET]：服务器成功返回用户请求的数据<br>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功<br>202 Accepted - [<em>]：表示一个请求已经进入后台排队（异步任务）<br>204 NO CONTENT - [DELETE]：用户删除数据成功<br>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作<br>401 Unauthorized - [</em>]：表示用户没有权限（令牌、用户名、密码错误）<br>403 Forbidden - [<em>] 表示用户得到授权（与401错误相对），但是访问是被禁止的<br>404 NOT FOUND - [</em>]：用户发出的请求针对的是不存在的记录，服务器没有进行操作<br>406 Not Acceptable - [GET]：用户请求的格式不可得<br>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的<br>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误<br>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flask’s-some-definitions&quot;&gt;&lt;a href=&quot;#Flask’s-some-definitions&quot; class=&quot;headerlink&quot; title=&quot;Flask’s some definitions&quot;&gt;&lt;/a&gt;Flask’s some d
      
    
    </summary>
    
      <category term="flask" scheme="http://reworth.site/categories/flask/"/>
    
    
      <category term="flask" scheme="http://reworth.site/tags/flask/"/>
    
      <category term="python" scheme="http://reworth.site/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>sed-grep</title>
    <link href="http://reworth.site/2018/01/01/sed-grep/"/>
    <id>http://reworth.site/2018/01/01/sed-grep/</id>
    <published>2018-01-01T09:20:47.000Z</published>
    <updated>2018-01-01T09:34:25.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed对文本的处理非常的强大，并且sed非常小，操作跟awk类似。sed是按顺序逐行进行读取文件。然后，它执行的是该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以将其存放到文件之中。</p><h2 id="sed-nefri-动作"><a href="#sed-nefri-动作" class="headerlink" title="sed  [-nefri] [动作]"></a>sed  [-nefri] [动作]</h2><ul><li>-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</li><li>-e ：直接在命令列模式上进行 sed 的动作编辑；</li><li>-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</li><li>-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</li><li>-i ：直接修改读取的文件内容，而不是输出到终端。</li><li>–follow-symlinks    直接修改文件时跟随软链接</li></ul><p><strong>动作说明</strong> ： [n1[,n2]]fuction<br>n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』<br> <strong>funtion</strong>：</p><ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><strong>命令格式</strong>： grep [option] pattern file</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>-i：忽略大小写</li><li>-c：打印匹配的行数</li><li>-v：查找不包含匹配项的行</li><li>-n：打印包含匹配项的行和行标</li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>^  #锚定行的开始 如：’^grep’匹配所有以grep开头的行。<br>$  #锚定行的结束 如：’grep$’匹配所有以grep结尾的行。<br>.  #匹配一个非换行符的字符 如：’gr.p’匹配gr后接一个任意字符，然后是p。<br>*  #匹配零个或多个先前字符 如：’<em>grep’匹配所有一个或多个空格后紧跟grep的行。<br>.</em>   #一起用代表任意字符。<br>[]   #匹配一个指定范围内的字符，如’[Gg]rep’匹配Grep和grep。<br>[^]  #匹配一个不在指定范围内的字符，如：’[^A-FH-Z]rep’匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。<br>(..)  #标记匹配字符，如’(love)‘，love被标记为1。<br>\&lt;      #锚定单词的开始，如:’\<grep'匹配包含以grep开头的单词的行。 \="">      #锚定单词的结束，如'grep\>‘匹配包含以grep结尾的单词的行。<br>x{m}  #重复字符x，m次，如：’0{5}‘匹配包含5个o的行。<br>x{m,}  #重复字符x,至少m次，如：’o{5,}‘匹配至少有5个o的行。<br>x{m,n}  #重复字符x，至少m次，不多于n次，如：’o{5,10}‘匹配5–10个o的行。<br>\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：’G\w*p’匹配以G后跟零个或多个文字或数字字符，然后是p。<br>\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </grep'匹配包含以grep开头的单词的行。></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sed&quot;&gt;&lt;a href=&quot;#sed&quot; class=&quot;headerlink&quot; title=&quot;sed&quot;&gt;&lt;/a&gt;sed&lt;/h2&gt;&lt;p&gt;sed对文本的处理非常的强大，并且sed非常小，操作跟awk类似。sed是按顺序逐行进行读取文件。然后，它执行的是该行指定的所有操作
      
    
    </summary>
    
      <category term="linux" scheme="http://reworth.site/categories/linux/"/>
    
    
      <category term="sed" scheme="http://reworth.site/tags/sed/"/>
    
      <category term="grep" scheme="http://reworth.site/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>awk</title>
    <link href="http://reworth.site/2017/12/29/awk/"/>
    <id>http://reworth.site/2017/12/29/awk/</id>
    <published>2017-12-29T10:00:59.000Z</published>
    <updated>2017-12-29T10:43:12.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p><strong>awk</strong>是一种处理文本的语言，是一个强大的文本分析工具，awk是以列为划分记数的，$0表示所有列，$1表示第一列，$2表示第二列。</p><h2 id="awk常用参数"><a href="#awk常用参数" class="headerlink" title="awk常用参数"></a>awk常用参数</h2><ul><li>-F指定输入文件分隔符，如-F：</li><li>-v 赋值一个用户定义变量，如-va=1</li><li>-f 从脚本文件中读取awk命令</li></ul><h2 id="多个分隔符"><a href="#多个分隔符" class="headerlink" title="多个分隔符"></a>多个分隔符</h2><p><code>awk -F &#39;[-|]&#39; &#39;{print $3}&#39; data</code><br>上面这个例子是以-和|为分隔符进行分割。</p><h2 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h2><p>设置awk自定义变量，使用参数-v<br><code>cat data.txt | awk -v a=9 &#39;{print $1,$1+a}&#39;</code><br>如上，设置了变量a的值，在输出的时候添加一个$1+a的值。<br>如果在脚本中使用的时候，前面已经定义了一个$2的变量，并且你就是像要使用这个变量的话，就要使用以下的形式：<br><code>awk &#39;{print $$2}&#39;</code></p><h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><p><code>cat data.txt | awk &#39;$1==&quot;reworth&quot; {print}</code><br>输出第一列为reworth的所有行。<br><code>cat data.txt | awk &#39;$1!=&quot;reworth&quot; {print}&#39;</code><br>输出第一列不是reworth的所有行。</p><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><p><code>cat data.txt | awk &#39;$2 ~ /reworth.*/ {print}&#39;</code><br>匹配第二列中以reworth开头的所有行。对某列进行匹配时需要在列之后加个～表示进行匹配。<br><code>cat data.txt | awk &#39;/reworth.*/ {print}&#39;</code><br>匹配以reworth开头的所有行。<br><strong>匹配取反</strong> !~<br><code>cat data.txt | awk &#39;$2 !~ /reworth/ {print}&#39;</code><br>匹配第二列不是reworth的所有行。</p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><ul><li>FILENAME : 当前输入文件名称</li><li>NF : 当前输入行的字段编号</li><li>OFS : 输出字段分隔符</li><li>NR : 当前输入行编号(是指输入行 1，2，3……等)</li><li>FS : 输入字段分隔符</li><li>ORS : 输出记录分隔符</li><li>RS : 输入记录分隔符</li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p><strong>substr字符串截取</strong><br><code>cat data.txt | awk &#39;{print substr($1,1,4)}&#39;</code><br>截取第一列中的第一个到第四个字符。<br><strong>split 切片</strong><br><code>cat data.txt |awk &#39;{split($1,a,&quot;,&quot;);print a[1],a[2],a[3]}&#39;</code><br>以逗号分隔第一列，并输出分隔后的数据。<br><strong>gsub 替换</strong><br><code>cat data.txt | awk &#39;&#39;{gsub(&quot;abc&quot;,&quot;asd&quot;,$2);print}</code><br>将第二列中的abc替换成asd</p><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><blockquote><p>grep ‘tower_activity_op’ /data/s*/log/test.log  | awk -F’[=,]’ ‘{a[$2] -= $12; b[$2] -= $14; item_count[$2]++;} END{for(i in a) {serverid=i;  cmd=”/usr/bin/mysql -u root -h \”192.168.0.1\” -p1234 -D stat -e \”replace into test(date,uid,cash,coins,number,code,serverid) values(\047’$Date’\047,”i”,”a[i]”,”b[i]”,”item_count[i]”,\047测试\047,”serverid”)\””; system(cmd);}}’ </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;awk&quot;&gt;&lt;a href=&quot;#awk&quot; class=&quot;headerlink&quot; title=&quot;awk&quot;&gt;&lt;/a&gt;awk&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;awk&lt;/strong&gt;是一种处理文本的语言，是一个强大的文本分析工具，awk是以列为划分记数的，$0表示所有列，$
      
    
    </summary>
    
      <category term="linux" scheme="http://reworth.site/categories/linux/"/>
    
    
      <category term="awk" scheme="http://reworth.site/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>volume-container</title>
    <link href="http://reworth.site/2017/12/28/volume-container/"/>
    <id>http://reworth.site/2017/12/28/volume-container/</id>
    <published>2017-12-28T11:00:24.000Z</published>
    <updated>2017-12-29T07:03:58.446Z</updated>
    
    <content type="html"><![CDATA[<p>volume container是专门为其他容器提供volume的容器。它提供的卷可以是bind mount,<br>也可以是docker managed volume.下面我创建一个volume container:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker create --name vc_data \</span><br><span class="line">-v ~/htdocs:/usr/local/apache2/htdocs \</span><br><span class="line">-v ~/other/useful/tools \</span><br><span class="line">busybox</span><br></pre></td></tr></table></figure></p><p>我们将容器命名为vc_data.注意这里执行的是docker create命令，这是因为volume container<br>的作用是只提供数据，它本身不需要处于运行状态。容器中mount了两个volume:</p><ul><li>bind mount,存放web server的静态文件。</li><li>docker managed volume,存放一些实用的工具<br>通过docker inspect可以查看这两个volume</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volume container是专门为其他容器提供volume的容器。它提供的卷可以是bind mount,&lt;br&gt;也可以是docker managed volume.下面我创建一个volume container:&lt;br&gt;&lt;figure class=&quot;highlight
      
    
    </summary>
    
      <category term="docker" scheme="http://reworth.site/categories/docker/"/>
    
    
      <category term="volume" scheme="http://reworth.site/tags/volume/"/>
    
  </entry>
  
</feed>
